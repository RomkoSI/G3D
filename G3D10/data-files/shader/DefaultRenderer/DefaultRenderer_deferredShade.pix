#version 410 or 410// -*- c++ -*-
/** \file DefaultRenderer_deferredShade.pix */
#ifdef GL_ARB_texture_query_lod
#extension GL_ARB_texture_query_lod : enable
#endif
#include <compatibility.glsl>
#include <g3dmath.glsl>
#include <LightingEnvironment/LightingEnvironment_uniforms.glsl>
#include <Light/Light.glsl>
#include <Texture/Texture.glsl>
#include <GBuffer/GBuffer.glsl>
#include <reconstructFromDepth.glsl>
#include <UniversalMaterial/UniversalMaterial_sample.glsl>

// Declare a GBuffer with no prefix
uniform_GBuffer(gbuffer_);

#ifdef ambientOcclusion_notNull
    uniform_Texture(sampler2D, ambientOcclusion_);
    uniform ivec2       ambientOcclusion_offset;
#endif
    
out Color3 result;

void main() {
    // Screen-space point being shaded
    ivec2 C = ivec2(gl_FragCoord.xy);
    
    UniversalMaterialSample surfel;

    // Surface normal
    Vector3 csN = texelFetch(gbuffer_CS_NORMAL_buffer, C, 0).xyz;
    if (dot(csN, csN) < 0.01) {
        // This is a background pixel, not part of an object
        discard;
    } else {
        surfel.tsNormal = surfel.geometricNormal = surfel.shadingNormal = surfel.glossyShadingNormal = normalize(mat3x3(gbuffer_camera_frame) * (csN * gbuffer_CS_NORMAL_readMultiplyFirst.xyz + gbuffer_CS_NORMAL_readAddSecond.xyz));
    }
    surfel.offsetTexCoord = Point2(0);

    // Point being shaded
    float csZ = reconstructCSZ(texelFetch(gbuffer_DEPTH_buffer, C, 0).r, gbuffer_camera_clipInfo);
    Point3 csPosition = reconstructCSPosition(gl_FragCoord.xy, csZ, gbuffer_camera_projInfo);
    surfel.position = (gbuffer_camera_frame * vec4(csPosition, 1.0)).xyz;
        //texelFetch(WS_POSITION_buffer, C, 0).xyz * WS_POSITION_readScaleBias.x + WS_POSITION_readScaleBias.y;
    
    // View vector
    Vector3 w_o = normalize(gbuffer_camera_frame[3] - surfel.position);

#   ifdef gbuffer_LAMBERTIAN_notNull    
        surfel.lambertianReflectivity = texelFetch(gbuffer_LAMBERTIAN_buffer, C, 0).rgb * invPi;
#   else
        surfel.lambertianReflectivity = Color3(0);
#   endif

    surfel.coverage = 1.0;

    {
        Color4  temp;
#       ifdef gbuffer_GLOSSY_notNull
            temp = texelFetch(gbuffer_GLOSSY_buffer, C, 0);
#       else
            temp = Color4(0);
#       endif
        surfel.fresnelReflectionAtNormalIncidence = temp.rgb;
        surfel.smoothness = temp.a;
    }

    surfel.transmissionCoefficient = Color3(0);
    surfel.collimation = 1.0;
#   ifdef gbuffer_EMISSIVE_notNull
        surfel.emissive = texelFetch(gbuffer_EMISSIVE_buffer, C, 0).rgb * gbuffer_EMISSIVE_readMultiplyFirst.rgb + gbuffer_EMISSIVE_readAddSecond.rgb;
#   else
        surfel.emissive = Radiance3(0);
#   endif

    surfel.lightMapRadiance = Radiance3(0);

    float glossyExponent = smoothnessToBlinnPhongExponent(surfel.smoothness);
    
    // Incoming reflection vector
    float cos_o = dot(surfel.glossyShadingNormal, w_o);
    Vector3 w_mi = normalize(surfel.glossyShadingNormal * (2.0 * cos_o) - w_o);

    Color3 F = schlickFresnel(surfel.fresnelReflectionAtNormalIncidence, max(0.0, cos_o), surfel.smoothness);
    Color3 lambertianColor = (1.0 - F) * surfel.lambertianReflectivity;

    // G = F * (s_X + 8) / (8 pi)
    Color3 glossyColor = F * (glossyExponent * (1.0 / (8.0 * pi)) + invPi);    

    Color3 E_lambertianAmbient = computeLambertianEnvironmentMapLighting(surfel.shadingNormal);
    Color3 E_glossyAmbient     = computeGlossyEnvironmentMapLighting(w_mi, (surfel.smoothness == 1.0), glossyExponent) 
        * ((8.0 * pi) / (glossyExponent + 8.0));

    Color3 E_glossy            = Color3(0);
    Color3 E_lambertian        = Color3(0);
    // The last argument just has to be any sampler to make the code compile
    computeDirectLighting(surfel.shadingNormal, surfel.glossyShadingNormal, w_o, surfel.geometricNormal, 1.0, surfel.position, glossyExponent, E_lambertian, E_glossy, gbuffer_LAMBERTIAN_buffer);   

    float AO =
#       ifdef ambientOcclusion_notNull
            (0.95 * texelFetch(ambientOcclusion_buffer, min(ivec2(gl_FragCoord.xy) + ambientOcclusion_offset, ivec2(ambientOcclusion_size.xy) - ivec2(1, 1)), 0).r + 0.05);
#       else
            1.0;
#       endif

    // How much ambient occlusion to apply to direct illumination (sort of approximates area lights,
    // more importantly: NPR term that adds local contrast)
    const float aoInfluenceOnDirectIllumination = 0.65;
    float directAO = lerp(1.0, AO, aoInfluenceOnDirectIllumination);

    result = 
            surfel.emissive +
           + (E_lambertian * directAO + E_lambertianAmbient * AO) * lambertianColor
           + (E_glossy     * directAO + E_glossyAmbient     * AO) * glossyColor;
}
