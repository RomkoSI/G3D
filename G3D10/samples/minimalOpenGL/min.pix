#version 410 // -*- c++ -*-

const float PI = 3.1415927;

in Varying {
    vec3            normal;
    vec2            texCoord;
    vec3            position;
} interpolated;


layout(shared, row_major) uniform Uniform {
    mat3x3      objectToWorldNormalMatrix;
    mat4x4      objectToWorldMatrix;
    mat4x4      modelViewProjectionMatrix;
    vec3        light;
    vec3        cameraPosition;
} object;

uniform sampler2D   colorTexture;

out vec4            pixelColor;

//////////////////////////////////////////////////////
// The following BRDF is based on https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf
// It is overkill for this demo, but shows something of what a modern shader looks like.

#if 0
float square(float x) { return x * x; }

float SchlickFresnel(float u) {
    // pow(m,5)
    float m = clamp(1.0 - u, 0.0, 1.0);
    return square(square(m)) * m;
}

float GTR1(float NdotH, float a) {
    if (a >= 1.0) { return 1.0 / PI; }
    float a2 = square(a);
    float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;
    return (a2 - 1.0) / (PI * log(a2) * t);
}

float GTR2(float NdotH, float a) {
    float a2 = square(a);
    float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;
    return a2 / (PI * t * t);
}


float smithG_GGX(float Ndotv, float alphaG)
{
    float a = alphaG*alphaG;
    float b = Ndotv*Ndotv;
    return 1/(Ndotv + sqrt(a + b - a*b));
}

vec3 mon2lin(vec3 x)
{
    return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));
}


vec3 BRDF(float roughness, float clearcoat, float clearcoatGloss, vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y) {
    float NdotL = dot(N, L);
    float NdotV = dot(N, V);
    if (NdotL < 0 || NdotV < 0) return vec3(0);

    vec3 H = normalize(L + V);
    float NdotH = dot(N, H);
    float LdotH = dot(L, H);

    vec3 Cdlin = mon2lin(baseColor);
    // luminance approx.
    float Cdlum = 0.3 * Cdlin[0] + 0.6 * Cdlin[1]  + 0.1 * Cdlin[2];

    // normalize lum. to isolate hue+sat
    vec3 Ctint = (Cdlum > 0.0) ? Cdlin / Cdlum : vec3(1.0); 
    vec3 Cspec0 = mix(specular * 0.08 * mix(vec3(1.0), Ctint, specularTint), Cdlin, metallic);
    vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint);

    // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing
    // and mix in diffuse retro-reflection based on roughness
    float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);
    float Fd90 = 0.5 + 2 * LdotH * LdotH * roughness;
    float Fd = mix(1, Fd90, FL) * mix(1, Fd90, FV);

    // Based on Hanrahan-Krueger BRDF approximation of isotropic BSSRDF
    // 1.25 scale is used to (roughly) preserve albedo
    // Fss90 used to "flatten" retroreflection based on roughness
    float Fss90 = LdotH * LdotH * roughness;
    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1 / (NdotL + NdotV) - 0.5) + 0.5);

    // Specular
    float aspect = sqrt(1.0 - anisotropic * 0.9);
    float ax = max(0.001, sqr(roughness)/aspect);
    float ay = max(0.001, sqr(roughness)*aspect);
    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);
    float FH = SchlickFresnel(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1.0), FH);
    float roughg = sqr(roughness * 0.5 + 0.5);
    float Gs = smithG_GGX(NdotL, roughg) * smithG_GGX(NdotV, roughg);

    // sheen
    vec3 Fsheen = FH * sheen * Csheen;

    // clearcoat (ior = 1.5 -> F0 = 0.04)
    float Dr = GTR1(NdotH, mix(0.1, 0.001, clearcoatGloss));
    float Fr = mix(0.04, 1.0, FH);
    float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);

    return ((1.0 / PI) * mix(Fd, ss, subsurface) * Cdlin + Fsheen) * (1.0 - metallic) + 
        Gs * Fs * Ds + 0.25 * clearcoat * Gr * Fr * Dr;
}
#endif

//////////////////////////////////////////////////////

void main () {
    vec3 normal          = normalize(interpolated.normal);

    // Simple normalized Blinn-Phong BRDF
    vec3 baseColor = texture(colorTexture, interpolated.texCoord).rgb;
    vec3 lambertianReflectance = baseColor * 0.8;

    const float smoothness = 0.3;

    const float glossyExponent = 100.0;
    vec3 glossyReflectance = vec3(0.2 * (glossyExponent + 8.0) / 8.0);

    vec3 view            = normalize(object.cameraPosition - interpolated.position);
    vec3 halfVector      = normalize(object.light + view);

    vec3 lightRadiance   = vec3(0.8, 0.75, 0.7) * 4.0;
    vec3 ambientRadiance = vec3(0.2, 0.25, 0.35) * 3.0;
    float cosTheta = max(0.0, dot(normal, object.light));

    // Approximately gamma correct
    pixelColor.rgb = sqrt(((lambertianReflectance + glossyReflectance * pow(max(0.0, dot(normal, halfVector)), glossyExponent)) * cosTheta * lightRadiance + 
                           lambertianReflectance * ambientRadiance) / PI);
    pixelColor.a = 1.0;
}

