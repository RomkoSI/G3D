#version 410 // -*- c++ -*-

const float PI = 3.1415927;

in Varying {
    vec3            normal;
    vec2            texCoord;
    vec3            position;
} interpolated;


layout(shared, row_major) uniform Uniform {
    mat3x3      objectToWorldNormalMatrix;
    mat4x4      objectToWorldMatrix;
    mat4x4      modelViewProjectionMatrix;
    vec3        light;
    vec3        cameraPosition;
} object;

uniform sampler2D   colorTexture;

out vec4            pixelColor;

//////////////////////////////////////////////////////
// The following BRDF is based on https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf
// It is overkill for this demo, but shows something of what a modern shader looks like.

#if 0
float square(float x) { return x * x; }

float SchlickFresnel(float u) {
    // pow(m,5)
    float m = clamp(1.0 - u, 0.0, 1.0);
    return square(square(m)) * m;
}

float GTR1(float NdotH, float a) {
    if (a >= 1.0) { return 1.0 / PI; }
    float a2 = square(a);
    float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;
    return (a2 - 1.0) / (PI * log(a2) * t);
}

float GTR2(float NdotH, float a) {
    float a2 = square(a);
    float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;
    return a2 / (PI * t * t);
}

float GTR2(float NdotH, float a) {
    float a2 = square(a);
    float t = 1.0 + (a2 - 1.0) * NdotH * NdotH;
    return a2 / (PI * square(t));
}

float GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay) {
    return 1.0 / ( PI * ax * ay * square(square(HdotX / ax) + square(HdotY / ay) + NdotH * NdotH ));
}

float SmithG_GGX(float Ndotv, float alphaG) {
    float a = alphaG * alphaG;
    float b = Ndotv * Ndotv;
    return 1.0 / (Ndotv + sqrt(a + b - a * b));
}

// See http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf
// and https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf
// for documentation of material parameters. Unlike their reference code, our baseColor is in linear
// space (not gamma encoded)
//
// L is the unit vector to the light source (omega_in) in world space
// N is the unit normal in world space
// V is the vector to the eye (omega_out) in world space
// X and Y are the tangent directions in world space
vec3 evaluateDisneyBRDF
   (vec3    baseColor,
    float   metallic,
    float   subsurface,
    float   specular,
    float   roughness,
    float   specularTint, 
    float   anisotropic,
    float   sheen,
    float   sheenTint,
    float   clearcoat, 
    float   clearcoatGloss,
    vec3    L,
    vec3    V,
    vec3    N,
    vec3    X,
    vec3    Y) {

    float NdotL = dot(N, L);
    float NdotV = dot(N, V);
    if (NdotL < 0 || NdotV < 0) return vec3(0);

    vec3 H = normalize(L + V);
    float NdotH = dot(N, H);
    float LdotH = dot(L, H);

    float luminance = dot(baseColor, vec3(0.3, 0.6, 0.1));

    // normalize luminance to isolate hue and saturation components
    vec3 Ctint = (luminance > 0.0) ? baseColor / luminance : vec3(1.0); 
    vec3 Cspec0 = mix(specular * 0.08 * mix(vec3(1.0), Ctint, specularTint), baseColor, metallic);
    vec3 Csheen = mix(vec3(1.0), Ctint, sheenTint);

    // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing
    // and mix in diffuse retro-reflection based on roughness
    float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);
    float Fd90 = 0.5 + 2.0 * LdotH * LdotH * roughness;
    float Fd = mix(1, Fd90, FL) * mix(1, Fd90, FV);

    // Based on Hanrahan-Krueger BRDF approximation of isotropic BSSRDF
    // 1.25 scale is used to (roughly) preserve albedo
    // Fss90 used to "flatten" retroreflection based on roughness
    float Fss90 = LdotH * LdotH * roughness;
    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);
    float ss = 1.25 * (Fss * (1 / (NdotL + NdotV) - 0.5) + 0.5);

    // Specular
    float aspect = sqrt(1.0 - anisotropic * 0.9);
    float ax = max(0.001, square(roughness) / aspect);
    float ay = max(0.001, square(roughness) * aspect);
    float Ds = GTR2_aniso(NdotH, dot(H, X), dot(H, Y), ax, ay);
    float FH = SchlickFresnel(LdotH);
    vec3 Fs = mix(Cspec0, vec3(1.0), FH);
    float roughg = sqr(roughness * 0.5 + 0.5);
    float Gs = smithG_GGX(NdotL, roughg) * smithG_GGX(NdotV, roughg);

    // sheen
    vec3 Fsheen = FH * sheen * Csheen;

    // clearcoat (ior = 1.5 -> F0 = 0.04)
    float Dr = GTR1(NdotH, mix(0.1, 0.001, clearcoatGloss));
    float Fr = mix(0.04, 1.0, FH);
    float Gr = smithG_GGX(NdotL, 0.25) * smithG_GGX(NdotV, 0.25);

    return ((1.0 / PI) * mix(Fd, ss, subsurface) * baseColor + Fsheen) * (1.0 - metallic) + 
        Gs * Fs * Ds + 0.25 * clearcoat * Gr * Fr * Dr;
}
#endif

//////////////////////////////////////////////////////

void main () {
    vec3 normal          = normalize(interpolated.normal);

    // Simple normalized Blinn-Phong BRDF
    vec3 baseColor = texture(colorTexture, interpolated.texCoord).rgb;
    vec3 lambertianReflectance = baseColor * 0.8;

    const float smoothness = 0.3;
    float roughness = square(1.0 - smoothness);

    const float glossyExponent = 100.0;
    vec3 glossyReflectance = vec3(0.2 * (glossyExponent + 8.0) / 8.0);

    vec3 view            = normalize(object.cameraPosition - interpolated.position);
    vec3 halfVector      = normalize(object.light + view);

    vec3 lightRadiance   = vec3(0.8, 0.75, 0.7) * 4.0;
    vec3 ambientRadiance = vec3(0.2, 0.25, 0.35) * 3.0;
    float cosTheta = max(0.0, dot(normal, object.light));

    // Approximately gamma correct
    pixelColor.rgb = sqrt(((lambertianReflectance + glossyReflectance * pow(max(0.0, dot(normal, halfVector)), glossyExponent)) * cosTheta * lightRadiance + 
                           lambertianReflectance * ambientRadiance) / PI);
    pixelColor.a = 1.0;
}

