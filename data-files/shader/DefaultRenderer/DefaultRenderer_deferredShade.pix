#version 410 or 420// -*- c++ -*-
/** \file DefaultRenderer_deferredShade.pix */
#ifdef GL_ARB_texture_query_lod
#extension GL_ARB_texture_query_lod : enable
#endif
#include <compatibility.glsl>
#include <g3dmath.glsl>
#include <Light/Light.glsl>
#include <GBuffer/GBuffer.glsl>
#include <reconstructFromDepth.glsl>
#include <LightingEnvironment/LightingEnvironment_LightUniforms.glsl>
#include <LightingEnvironment/LightingEnvironment_environmentMapUniforms.glsl>


// Declare a GBuffer with no prefix
uniform_GBuffer(gbuffer_);

#ifdef ambientOcclusion_notNull
    uniform_Texture(sampler2D, ambientOcclusion_);
    uniform ivec2       ambientOcclusion_offset;
#endif
    
out Color3 result;

void main() {
    // Screen-space point being shaded
    ivec2 C = ivec2(gl_FragCoord.xy);
    
    UniversalMaterialSample surfel;

    // Surface normal
    Vector3 csN = texelFetch(gbuffer_CS_NORMAL_buffer, C, 0).xyz;
    if (dot(csN, csN) < 0.01) {
        // This is a background pixel, not part of an object
        discard;
    } else {
        surfel.tsNormal = surfel.geometricNormal = surfel.shadingNormal = surfel.glossyShadingNormal = normalize(mat3x3(gbuffer_camera_frame) * (csN * gbuffer_CS_NORMAL_readMultiplyFirst.xyz + gbuffer_CS_NORMAL_readAddSecond.xyz));
    }
    surfel.offsetTexCoord = Point2(0);

    // Point being shaded
    float csZ = reconstructCSZ(texelFetch(gbuffer_DEPTH_buffer, C, 0).r, gbuffer_camera_clipInfo);
    Point3 csPosition = reconstructCSPosition(gl_FragCoord.xy, csZ, gbuffer_camera_projInfo);
    surfel.position = (gbuffer_camera_frame * vec4(csPosition, 1.0)).xyz;
        //texelFetch(WS_POSITION_buffer, C, 0).xyz * WS_POSITION_readScaleBias.x + WS_POSITION_readScaleBias.y;
    
    // View vector
    Vector3 w_o = normalize(gbuffer_camera_frame[3] - surfel.position);

#   ifdef gbuffer_LAMBERTIAN_notNull    
        surfel.lambertianReflectivity = texelFetch(gbuffer_LAMBERTIAN_buffer, C, 0).rgb * invPi;
#   else
        surfel.lambertianReflectivity = Color3(0);
#   endif

    surfel.coverage = 1.0;

    {
        Color4  temp;
#       ifdef gbuffer_GLOSSY_notNull
            temp = texelFetch(gbuffer_GLOSSY_buffer, C, 0);
#       else
            temp = Color4(0);
#       endif
        surfel.fresnelReflectionAtNormalIncidence = temp.rgb;
        surfel.smoothness = temp.a;
    }

    surfel.transmissionCoefficient = Color3(0);
    surfel.collimation = 1.0;
#   ifdef gbuffer_EMISSIVE_notNull
        surfel.emissive = texelFetch(gbuffer_EMISSIVE_buffer, C, 0).rgb * gbuffer_EMISSIVE_readMultiplyFirst.rgb + gbuffer_EMISSIVE_readAddSecond.rgb;
#   else
        surfel.emissive = Radiance3(0);
#   endif

    surfel.lightMapRadiance = Radiance3(0);

    // Environment lighting
    Radiance3 L_scatteredIndirect;
    {
        float glossyExponent = smoothnessToBlinnPhongExponent(surfel.smoothness);
    
        // Incoming reflection vector
        float cos_o = dot(surfel.glossyShadingNormal, w_o);
        Vector3 w_mi = normalize(surfel.glossyShadingNormal * (2.0 * cos_o) - w_o);

        // For mirror reflection (which is the only thing we can use for the evt light), the
        // half vector is the normal, so w_h . w_o == n . w_o 
        Color3 F = schlickFresnel(surfel.fresnelReflectionAtNormalIncidence, max(0.0, cos_o), surfel.smoothness);
        Color3 lambertianColor = (1.0 - F) * surfel.lambertianReflectivity;

        // G = F * (s_X + 8) / (8 pi)
        Color3 glossyColor = F * (glossyExponent * (1.0 / (8.0 * pi)) + invPi);    

        Color3 lambertianAmbient = computeLambertianEnvironmentMapLighting(surfel.shadingNormal);
        Color3 glossyAmbient     = computeGlossyEnvironmentMapLighting(w_mi, (surfel.smoothness == 1.0), glossyExponent);

        L_scatteredIndirect = lambertianAmbient * lambertianColor + glossyAmbient * F;
    }

    // TODO: Remove the pi term here is a correction for backwards compatability to G3D 10.0, which
    // had everything brighter by pi
    Radiance3 L_scatteredDirect = computeDirectLighting(surfel, w_o, 1.0) * pi;

    float AO =
#       ifdef ambientOcclusion_notNull
            (0.95 * texelFetch(ambientOcclusion_buffer, min(ivec2(gl_FragCoord.xy) + ambientOcclusion_offset, ivec2(ambientOcclusion_size.xy) - ivec2(1, 1)), 0).r + 0.05);
#       else
            1.0;
#       endif

    // How much ambient occlusion to apply to direct illumination (sort of approximates area lights,
    // more importantly: NPR term that adds local contrast)
    const float aoInfluenceOnDirectIllumination = 0.65;
    float directAO = lerp(1.0, AO, aoInfluenceOnDirectIllumination);

    result = surfel.emissive + L_scatteredDirect * directAO + L_scatteredIndirect * AO;
}
